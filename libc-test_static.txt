调试用户程序的技巧：
比如调试测试文件stat.c
vscode在gdb中输入：
-exec file fsimg/libc-test/entry-static.exe
-exec break stat_main
即可跳转到这个用户程序进行debug


./runtest.exe -w entry-static.exe fdopen
问题一：
创建文件 /tmp/a 需要是合法的，即支持递归创建
解决1：
直接mkdir 一个 /tmp（可能评测机上的sdcard镜像没有/tmp目录，但是linux上有/tmp目录）
解决2：
在系统初始化的时候在 / 中创建一个 /tmp
比如在init.c中创建一个目录即可。（或者在内核中创建一个目录）
问题二：
fat32_fcb_delete中的
ASSERT(off-long_dir_len>=0) 少写了一个等号
[ok]


./runtest.exe -w entry-static.exe fscanf 
busybox sh busybox/busybox_testcode.sh
问题一：
管道 read 之后就卡住了，原因是管道仅仅写入了13个字符，但是read 需要读取1024个字符，管道中没有1024个字符，所以读者（消费者没有被唤醒）
已经解决：
在sbuf_remove中添加
if(sp->r == sp->w && sp->w!=0) {
    return 1; 
}// bug!!!

问题二：
writev 卡住，在获取inode 的锁的时候卡住，两次获取一个锁
解决：
在writev 的if结尾加一个unlock
if (f->f_type == FD_INODE) {
    struct inode *ip;
    ip = f->f_tp.f_inode;
    ip->i_op->ilock(ip);
    if (S_ISDIR(ip->i_mode)) {
        // writev 不应该写目录
        ip->i_op->iunlock(ip);
        return -1;
    }
    ip->i_op->unlock(ip); // 忘记写了
}
问题三：
[PAGEFAULT]: va is not in the vmas， 访问非法内存
[ok]



./runtest.exe -w entry-static.exe setjmp
似乎是信号相关的测试（主要是sigprocmask），报错的原因是：
src/functional/setjmp.c:62: sigismember(&set2, SIGUSR1)==1 failed: siglongjmp incorrectly restored mask
没有保存正确的mask
似乎是SIG_SETMASK没有设置正确
应该是下面的这三个
#define SIG_BLOCK          0	/* for blocking signals */
#define SIG_UNBLOCK        1	/* for unblocking signals */
#define SIG_SETMASK        2	/* for setting the signal mask */
还有就是一些小bug，比如：
copyout 写成了 copyin
t->blocked.sig = set->sig; 写成了  t->blocked = *set;


./runtest.exe -w entry-static.exe stat 
问题一：
似乎是获取文件信息的时间字段没有填充导致无法通过测试：
TEST(st.st_ctime<=t, "%jd > %jd\n", (intmax_t)st.st_ctime, (intmax_t)t);
TEST(st.st_mtime<=t, "%jd > %jd\n", (intmax_t)st.st_mtime, (intmax_t)t);
TEST(st.st_atime<=t, "%jd > %jd\n", (intmax_t)st.st_atime, (intmax_t)t);
加上st_ctime、st_mtime和st_atime的赋值即可

问题二：
TEST(stat("/dev/null",&st)==0, "errno = %s\n", strerror(errno))出错
原因是系统中没有创建/dev/null 这个设备文件，我们在init.c中初始化的时候初始化一个即可

在linux的 /dev中 ls -lh | less 搜索 null和 zero可以发现这两个问题是可读、可写、并且都是字符设备
crw-rw-rw-   1 root       root      1,     3  7月  3 17:32 null
crw-rw-rw-   1 root       root      1,     5  7月  3 17:32 zero
下面是作为console的tty文件：
crw--w----   1 root       tty       5,     1  7月  3 17:32 console
需要注意的是，只需要mknod即可，不要用openat！
// for /dev/null
mknod("/dev/null", S_IFCHR, DEV_NULL << 8);
// for /dev/zero
mknod("/dev/zero", S_IFCHR, DEV_ZERO << 8);

问题三：
报如下的错误：
src/functional/stat.c:36: st.st_gid==getegid() failed: 0 vs 0
这次似乎是sys_fstat的问题
发现是sys_getgid、sys_getegid和i_gid、i_uid设置不匹配导致的，改过来就好了。

问题四：
运行第二遍出现错误
开启strace就出现错误？？？关闭strace就没有错误？？
src/functional/stat.c:20: st.st_nlink>0 failed: 0
但是在内核中输出的n_link 是1，和用户态的结果不一致
主要原因是内核中定义的结构体类型和用户程序定义的结构体类型不一致，这里需要注意i_ino 在非x86架构下是uint32，不能写成uint64
最好将下面这些字段的类型统一
typedef unsigned long int dev_t;
typedef unsigned long int ino_t;
typedef unsigned int nlink_t;
typedef unsigned int uid_t;
typedef unsigned int gid_t;
typedef long int blksize_t;
typedef long int blkcnt_t;
typedef unsigned int mode_t;



./runtest.exe -w entry-static.exe daemon_failure
问题：
src/regression/daemon-failure.c:52: daemon should have failed with 24 [EMFILE] got 1
内核中的函数没有正确返回EMFILE这个错误码
在内核中凡是文件描述符用完了的地方改为 return -EMFILE即可



./runtest.exe -w entry-static.exe ftello_unflushed_append
似乎是sys_lseek的错误:
src/regression/ftello-unflushed-append.c:34: ftello is broken before flush: got 3, want 7
主要原因是
f = fdopen(fd, "a") 这个语句没有在内核中生效，没有成功设置f_pos为文件的末尾
这就需要弄清楚fdopen中调用了什么系统调用：
if (*mode == 'a') {
    int flags = __syscall(SYS_fcntl, fd, F_GETFL);
    if (!(flags & O_APPEND))
        __syscall(SYS_fcntl, fd, F_SETFL, flags | O_APPEND);
    f->flags |= F_APP;
}
即先通过fcntl获取文件的属性，查看是否有O_APPEND属性，如果没有那么就再次调用fcntl设置文件的属性含有O_APPEND
最后还发现了inode_create的一些bug，就是在create后不能用unlock_put(dp)，而是用unlock()即可，不然ip->parent就不在内存中，那么page cache就失效了

最后的解决办法就是将inode_create 和 namex统一起来，加上create_cnt和create_first字段表示某个inode 调用了create多少次，某个inode是否是通过create获取，在返回的时候确保
ip的parent是在内存中有效的。


./runtest.exe -w entry-static.exe lseek_large
报下面这个错误：
src/regression/lseek-large.c:24: lseek(fd, 0x80000000, SEEK_SET) got 0xffffffffffffffff
似乎是变量类型错误
主要原因是 f_pos 写成了uint32 ，应该改为 off_t，即long
还有就是sys_lseek 中获取的offset写成了这个：
if (argint(1, (int *)&offset) < 0) {
    return -1;
}
应该用arglong ：
if (arglong(1, &offset) < 0) {
    return -1;
}


./runtest.exe -w entry-static.exe statvfs
需要注意的是statfs的结构体定义一定要正确，否则会发生copyout错误的情况：
struct statfs {
	unsigned long f_type, f_bsize;
	fsblkcnt_t f_blocks, f_bfree, f_bavail;
	fsfilcnt_t f_files, f_ffree;
	fsid_t f_fsid;
	unsigned long f_namelen, f_frsize, f_flags, f_spare[4];
};


./runtest.exe -w entry-static.exe syscall_sign_extend
虽然我们在 init.c 中添加了/dev/null 和 /dev/zero，但是语义实现有问题

/dev/null（空设备文件或黑洞文件）是一个特殊的设备文件，所有写入其中的数据，都会被丢弃的无影无踪，
/dev/null通常被用于丢弃不需要的数据输出，或作为用于输入流的空文件。
和/dev/null类似，/dev/zero也是一个特殊的字符设备文件，当我们使用或读取它的时候，它会提供无限连续不断的空的数据流（特殊的数据格式流）

null： write n 个字符， 返回 n， 不需要任何操作，read n 个 字符，返回0，不需要任何操作
类别为一个黑洞，写n个字符就吞n个字符，不会保存，但返回值为n（的确写了，但是消失了）；黑洞只写，不读（无法逃离黑洞）
zero： write n 个字符， 返回 0， 不需要任何操作，read n 个 字符，返回n，返回n个zero
类别为一个空字符生成自动机，读n个字符就返回n个空字符，返回n（的确读了，但是为空字符）；生成自动机只读，不写（没有保存的空间）


./runtest.exe -w entry-static.exe pthread_cancel_points 



./runtest.exe -w entry-static.exe pthread_cancel 
./runtest.exe -w entry-static.exe pthread_cond 
./runtest.exe -w entry-static.exe pthread_tsd 
./runtest.exe -w entry-static.exe pthread_robust_detach
./runtest.exe -w entry-static.exe pthread_cancel_sem_wait
./runtest.exe -w entry-static.exe pthread_cond_smasher
./runtest.exe -w entry-static.exe pthread_condattr_setclock
./runtest.exe -w entry-static.exe pthread_exit_cancel
./runtest.exe -w entry-static.exe pthread_once_deadlock
./runtest.exe -w entry-static.exe pthread_rwlock_ebusy



./runtest.exe -w entry-static.exe rlimit_open_files
出现下面的问题：
src/regression/rlimit-open-files.c:30: more fds are open than rlimit allows: fd=127, limit=42
TODO ： sys_prlimit64 需要实现

./runtest.exe -w entry-static.exe utime
TODO ： sys_utimensat 需要实现

# ./runtest.exe -w entry-static.exe sscanf_long
TODO : sys_prlimit64 需要实现


./runtest.exe -w entry-static.exe socket 
TODO: socket 系统调用需要实现
